import pygame as pg
from grid import *
from a_star import perform_a_star
from lpa_star import perform_lpa_star
from d_star_lite import perform_d_star_lite

'''The following are the available command keys for this pathfinding 
program.'''

# LEFT MOUSE CLICK
    # The first click places the start node.
    # The second click places the goal node.
    # Clicks after these nodes are placed will create barriers of the 
    # type determined by whatever type has been selected using the 
    # 'z' key toggle.
    # Note that algorithms cannot start until a start and end node 
    # have been selected.

# RIGHT MOUSE CLICK
    # Clears a node of any unique status (becomes an empty node).

# KEY 'z'
    # Toggle between vis (visible) and invis (invisible) barriers.

# KEY 'g'
    # This will generate a graph with barriers. 
    # The number of barriers corresponds to the set obstacle density 
    # of the program, which is by default 25%. 
    # Toggle the default obstacle density by changing the 
    # BARRIER_RAND_CONST in grid.py. 
    # In the program, you can toggle the type of barrier to be
    # generated by pressing the key 'z'. 
    # Pressing 'z' toggles between invis barrier generation and vis 
    # barrier generation.

# KEY 'm'
    # This will generate a graph with barriers like when pressing 
    # key 'g', except in this case a mixture of invis and vis barriers 
    # will be generated. 
    # When a node is selected to be a barrier during generation, there 
    # is a 50-50 chance of an invis or vis barrier being generated.

# KEY 'c'
    # Clear the grid (all nodes become empty nodes).

# KEY 's'
    # Clear the grid of all nodes that are paths, open, or closed. 
    # Node statuses are described in node.py.

# KEY 'b'
    # Restore the graph to its state before the last search algorithm 
    # was initiated.

# KEY '1'
    # Initiate A* without travel.

# KEY '2'
    # Initiate A* with travel.

# KEY '3'
    # Initiate LPA*.

# KEY '4'
    # Initiate D* Lite.


def handle_left_click(start, end, node, barriers_are_vis):
    
    if not (start or end):
        start = node
        start.make_start()

    elif not (end or node is start):
        end = node
        end.make_end()

    elif not (start or node is end):
        start = node
        start.make_start()

    elif not (node is end or node is start):
        
        if barriers_are_vis:
            node.make_vis_barrier()
        
        else:
            node.make_invis_barrier()
    
    return start, end


def handle_right_click(start, end, node):
    node.reset()
    
    if node is start:
        start = None
    
    elif node is end:
        end = None

    return start, end


def handle_search_keys(event, grid, start, end, invis_barriers):
    
    [node.update_neighbors(grid) for row in grid for node in row]
    
    start.make_start()
    end.make_end()

    prior_grid = prior_start = prior_end = None

    # do A* without traversal to goal
    if event.key == pg.K_1:
        prior_grid, prior_start, prior_end = duplicate_grid(grid)
        invis_barriers = [
            node for row in grid for node in row 
            if node.is_invis_barrier()
        ]
        
        perform_a_star(lambda: draw(grid), grid, start, end, invis_barriers, False)

    # do A* with traversal to goal
    elif event.key == pg.K_2:
        prior_grid, prior_start, prior_end = duplicate_grid(grid)
        invis_barriers = [
            node for row in grid for node in row 
            if node.is_invis_barrier()
        ]

        perform_a_star(lambda: draw(grid), grid, start, end, invis_barriers, True)

    # do LPA*
    elif event.key == pg.K_3:
        prior_grid, prior_start, prior_end = duplicate_grid(grid)
        invis_barriers = [
            node for row in grid for node in row 
            if node.is_invis_barrier()
        ]

        perform_lpa_star(lambda: draw(grid), grid, start, end, invis_barriers)

    # do D* Lite
    elif event.key == pg.K_4:
        prior_grid, prior_start, prior_end = duplicate_grid(grid)
        
        perform_d_star_lite(lambda: draw(grid), grid, start, end)
    
    priors = None

    if prior_grid:
        priors = (prior_grid, prior_start, prior_end)
    
    return priors, invis_barriers 


def handle_prep_keys(
        event, grid, start, end, prior_grid, prior_start, prior_end, barriers_are_vis
):
    # clear grid
    if event.key == pg.K_c:
        start = None
        end = None
        grid = make_grid()

        # "safe clear" grid - remove everything except barriers, 
        # start, and end
    elif event.key == pg.K_s:
        l = lambda n: n.is_open() or n.is_closed() or n.is_path()
        [node.reset() for row in grid for node in row if l(node)]

    # toggle barrier type (vis or invis)
    elif event.key == pg.K_z:
        barriers_are_vis = not barriers_are_vis

    # generate barriers
    elif event.key == pg.K_g:
        start = None
        end = None
        grid = make_grid()
        generate_barriers(grid, barriers_are_vis)

    # generate a mix of invis and vis barriers
    elif event.key == pg.K_m:
        start = None
        end = None
        grid = make_grid()
        generate_barriers_mixed(grid)

    # restore grid to original version preceding latest algorithm 
    # visualization
    elif event.key == pg.K_b:
        grid = prior_grid
        start = prior_start
        end = prior_end
    
    return grid, start, end, barriers_are_vis


def handle_interaction(event, env):
    pos = pg.mouse.get_pos()
    row, col = get_clicked_pos(pos)
    node = env['grid'][row][col]

    if pg.mouse.get_pressed()[0]: # left click
        handle_left_click(node, env)
    
    elif pg.mouse.get_pressed()[2]:  # Right click
        handle_right_click(node, env)

    if event.type == pg.KEYDOWN:
        
        if env['start'] and env['end']:
            priors, barriers = handle_search_keys(event, grid, start, end, invis_barriers)

            if priors:
                prior_grid, prior_start, prior_end = priors
            
            invis_barriers = barriers

        grid, start, end, barriers_are_vis = handle_prep_keys(event, grid, start, end, prior_grid, prior_start, prior_end, barriers_are_vis)
    
    return grid, start, end, prior_grid, prior_start, prior_end, barriers_are_vis, invis_barriers


def main():
    run = True
    env = {
        'grid': make_grid(),
        'start': None,
        'end': None,
        'prior_grid': None,
        'prior_start': None,
        'prior_end': None,
        'barriers_are_vis': True,
        'invis_barriers': []
    }

    while run:
        draw(env['grid'])

        for event in pg.event.get():

            if event.type == pg.QUIT:
                run = False

            handle_interaction(event, env)

    pg.quit()


if __name__ == '__main__':
    main()

