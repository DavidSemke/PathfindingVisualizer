import pygame as pg
from grid import *
from a_star import perform_a_star
from lpa_star import perform_lpa_star
from d_star_lite import perform_d_star_lite

'''The following are the available command keys for this pathfinding 
program.'''

# LEFT MOUSE CLICK
    # The first click places the start node.
    # The second click places the goal node.
    # Clicks after these nodes are placed will create barriers of the 
    # type determined by whatever type has been selected using the 
    # 'z' key toggle.
    # Note that algorithms cannot start until a start and end node 
    # have been selected.

# RIGHT MOUSE CLICK
    # Clears a node of any unique status (becomes an empty node).

# KEY 'z'
    # Toggle between vis (visible) and invis (invisible) barriers.

# KEY 'g'
    # This will generate a graph with barriers. 
    # The number of barriers corresponds to the set obstacle density 
    # of the program, which is by default 25%. 
    # Toggle the default obstacle density by changing the 
    # BARRIER_RAND_CONST in grid.py. 
    # In the program, you can toggle the type of barrier to be
    # generated by pressing the key 'z'. 
    # Pressing 'z' toggles between invis barrier generation and vis 
    # barrier generation.

# KEY 'm'
    # This will generate a graph with barriers like when pressing 
    # key 'g', except in this case a mixture of invis and vis barriers 
    # will be generated. 
    # When a node is selected to be a barrier during generation, there 
    # is a 50-50 chance of an invis or vis barrier being generated.

# KEY 'c'
    # Clear the grid (all nodes become empty nodes).

# KEY 's'
    # Clear the grid of all nodes that are paths, open, or closed. 
    # Node statuses are described in node.py.

# KEY 'b'
    # Restore the graph to its state before the last search algorithm 
    # was initiated.

# KEY '1'
    # Initiate A* without travel.

# KEY '2'
    # Initiate A* with travel.

# KEY '3'
    # Initiate LPA*.

# KEY '4'
    # Initiate D* Lite.


def handle_left_click(env, node, barriers_are_vis):
    grid, start, end = env
    
    if not (start or end):
        start = node
        start.make_start()

    elif not (end or node is start):
        end = node
        end.make_end()

    elif not (start or node is end):
        start = node
        start.make_start()

    elif not (node is end or node is start):
        
        if barriers_are_vis:
            node.make_vis_barrier()
        
        else:
            node.make_invis_barrier()
    
    return (grid, start, end)


def handle_right_click(env, node):
    grid, start, end = env
    node.reset()
    
    if node is start:
        start = None
    
    elif node is end:
        end = None

    return (grid, start, end)


def handle_search_keys(event, env, invis_barriers):
    grid, start, end = env
    
    [node.update_neighbors(grid) for row in grid for node in row]
    
    start.make_start()
    end.make_end()
    prior_env = None

    # do A* without traversal to goal
    if event.key == pg.K_1:
        prior_env = duplicate_grid(grid)
        invis_barriers = [
            node for row in grid for node in row 
            if node.is_invis_barrier()
        ]
        
        perform_a_star(lambda: draw(grid), env, invis_barriers, False)

    # do A* with traversal to goal
    elif event.key == pg.K_2:
        prior_env = duplicate_grid(grid)
        invis_barriers = [
            node for row in grid for node in row 
            if node.is_invis_barrier()
        ]

        perform_a_star(lambda: draw(grid), env, invis_barriers, True)

    # do LPA*
    elif event.key == pg.K_3:
        prior_env = duplicate_grid(grid)
        invis_barriers = [
            node for row in grid for node in row 
            if node.is_invis_barrier()
        ]

        perform_lpa_star(lambda: draw(grid), env, invis_barriers)

    # do D* Lite
    elif event.key == pg.K_4:
        prior_env = duplicate_grid(grid)
        
        perform_d_star_lite(lambda: draw(grid), env)
    
    return prior_env, invis_barriers


def handle_prep_keys(
        event, env, prior_env, barriers_are_vis
):
    grid, start, end = env

    # clear grid
    if event.key == pg.K_c:
        start = None
        end = None
        grid = make_grid()

        # "safe clear" grid - remove everything except barriers, 
        # start, and end
    elif event.key == pg.K_s:
        l = lambda n: n.is_open() or n.is_closed() or n.is_path()
        [node.reset() for row in grid for node in row if l(node)]

    # toggle barrier type (vis or invis)
    elif event.key == pg.K_z:
        barriers_are_vis = not barriers_are_vis

    # generate barriers
    elif event.key == pg.K_g:
        start = None
        end = None
        grid = make_grid()
        generate_barriers(grid, barriers_are_vis)

    # generate a mix of invis and vis barriers
    elif event.key == pg.K_m:
        start = None
        end = None
        grid = make_grid()
        generate_barriers_mixed(grid)

    # restore grid to original version preceding latest algorithm 
    # visualization
    elif event.key == pg.K_b:
        prev_grid, prev_start, prev_end = prior_env
        grid = prev_grid
        start = prev_start
        end = prev_end
    
    env = (grid, start, end)
    
    return (env, barriers_are_vis)


def handle_interaction(
        event, env, prior_env, barriers_are_vis, invis_barriers
):
    grid, start, end = env

    pos = pg.mouse.get_pos()
    row, col = get_clicked_pos(pos)
    node = grid[row][col]

    if pg.mouse.get_pressed()[0]: # left click
        env = handle_left_click(env, node, barriers_are_vis)
    
    elif pg.mouse.get_pressed()[2]:  # Right click
        env = handle_right_click(env, node)

    elif event.type == pg.KEYDOWN:

        if start and end:
            results = handle_search_keys(event, env, invis_barriers)
            triple, barriers = results
            prior_env = triple if triple else prior_env
            invis_barriers = barriers
        
        results = handle_prep_keys(
            event, env, prior_env, barriers_are_vis
        )
        env, barriers_are_vis = results
    
    return (env, prior_env, barriers_are_vis, invis_barriers)


def main():
    grid = make_grid()
    start = None
    end = None
    run = True
    barriers_are_vis = True
    invis_barriers = []
    env = (grid, start, end)
    prior_env = env

    while run:
        grid, _, _ = env
        draw(grid)

        for event in pg.event.get():

            if event.type == pg.QUIT:
                run = False

            results = handle_interaction(
                event, env, prior_env, barriers_are_vis, 
                invis_barriers
            )

            env, prior_env, barriers_are_vis, invis_barriers = results

    pg.quit()


if __name__ == '__main__':
    main()

